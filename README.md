# GoWasmBake

GoWasmBake is a proof of concept for reducing runtime costs of WASM files generated by Go 1.11. It basically runs all
the Go code up until `main.main`, bakes in that runtime information (e.g. memory data, JS syscalls, etc) in a new WASM
environment, makes the new WASM environment jump right to `main.main`, and does a couple of other minor WASM trimming
tricks.

**NOTE: As a proof of concept, it is not tested with many scenarios and may not work in all cases.**
**This is just an experiment and should not be used in production.**
**See "Caveats" in the "How it Works" section.**

## Results

On the simple hello world example from the next section, GoWasmBake achieves the following:

* Saved ~17% of the file size (2,445,309 bytes to 2,022,376 bytes)
* Skipped over 4,205,101 instructions pre-`main.main` instructions (not all are executable instructions of course)
* Skipped over and removed code for 13 package init functions
* Took 11,649 instances of a common 9-insn pattern and changed each to a 2-insn call (i.e. un-inlined)

Measurements have not been done on the following and would be welcomed by anyone willing to do them:

* Performance impact of exchanging all those startup instructions for fixed memory data
* GZIP'd impact of the final file

## Usage and Example

Prerequisites:

* Go 1.11 installed and on the `PATH`
* Java 1.8+ installed and on the `PATH`
* Latest Node.js installed and on the `PATH`
* GoWasmBake [latest release](https://github.com/cretz/go-wasm-bake/releases) extracted with `bin/` on the `PATH`

First, make a simple `hello-world.go` file containing:

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	fmt.Printf("From %v - Hello, %v!", os.Args[0], os.Args[1])
}
```

Set environment variable `GOOS` to `js` and `GOARCH` to `wasm`. Then compile `hello-world.go` to
`hello-world.orig.wasm`:

    go build -o hello-world.orig.wasm hello-world.go

The WASM file is ~2.33MB. Now, from the Go install base, copy the wasm executor JS file over:

    cp $GOROOT/misc/wasm_exec.js wasm_exec.orig.js

Test it:

    node wasm_exec.orig.js hello-world.orig.wasm foo

Which will output:

    From hello-world.orig.wasm - Hello, foo!

Now bake it with two args, first being the program name `hello-world.baked.wasm` and the second being the first arg
`foo`:

    go-wasm-bake hello-world.orig.wasm hello-world.baked.wasm --arg hello-world.baked.wasm --arg foo

It will take a minute or so and give some output like:

    [INFO] Starting bake on hello-world.orig.wasm with args [hello-world.baked.wasm, foo]             
    [INFO] Baked WASM in 83752 ms, went from 2445309 to 2022376 bytes (17% smaller)                   
    [INFO] Went from 4205212 insns until main.main to 111                                             
    [INFO] Saving to hello-world.baked.wasm                                                           
    [INFO] JS required before go.run call in JS:                                                      
    -------------------                                                                               
    const putRef = (v) => {                                                                           
      const nanHead = 0x7FF80000;                                                                     
      if (v === undefined || v === null || v === true || v === false || typeof v === 'number') return;
      if (!this._refs.has(v)) {                                                                       
        const ref = this._values.length;                                                              
        this._values.push(v);                                                                         
        this._refs.set(v, ref);                                                                       
      }                                                                                               
    }                                                                                                 
    putRef(Reflect.get(this._values[5], 'Array'));                                                    
    putRef(Reflect.get(this._values[5], 'Object'));                                                   
    putRef(Reflect.get(this._values[5], 'Array'));                                                    
    putRef(Reflect.construct(this._values[8], []));                                                   
    putRef(Reflect.get(this._values[5], 'Go'));                                                       
    putRef(Reflect.get(this._values[11], '_makeCallbackHelper'));                                     
    putRef(Reflect.get(this._values[5], 'Go'));                                                       
    putRef(Reflect.get(this._values[11], '_makeEventCallbackHelper'));                                
    putRef(Reflect.get(this._values[5], 'Int8Array'));                                                
    putRef(Reflect.get(this._values[5], 'Int16Array'));                                               
    putRef(Reflect.get(this._values[5], 'Int32Array'));                                               
    putRef(Reflect.get(this._values[5], 'Uint8Array'));                                               
    putRef(Reflect.get(this._values[5], 'Uint16Array'));                                              
    putRef(Reflect.get(this._values[5], 'Uint32Array'));                                              
    putRef(Reflect.get(this._values[5], 'Float32Array'));                                             
    putRef(Reflect.get(this._values[5], 'Float64Array'));                                             
    putRef(Reflect.get(this._values[5], 'process'));                                                  
    putRef(Reflect.get(this._values[5], 'fs'));                                                       
    putRef(Reflect.get(this._values[23], 'constants'));                                               
    putRef(Reflect.get(this._values[24], 'O_WRONLY'));                                                
    putRef(Reflect.get(this._values[24], 'O_RDWR'));                                                  
    putRef(Reflect.get(this._values[24], 'O_CREAT'));                                                 
    putRef(Reflect.get(this._values[24], 'O_TRUNC'));                                                 
    putRef(Reflect.get(this._values[24], 'O_APPEND'));                                                
    putRef(Reflect.get(this._values[24], 'O_EXCL'));                                                  

Now `hello-world.baked.wasm` is ~1.92 MB. Some JS was given as a result of that command. It needs to be placed in the
WASM execution JS. First copy it over:

    cp wasm_exec.orig.js wasm_exec.baked.js

Then, just before the `while(true)` call, add the code above. This essentially makes the syscalls that the other WASM
does during initialization. Now, run it:

    node wasm_exec.baked.js hello-world.baked.js foo

Note, due to how baking works, the args must exactly match what was sent to `go-wasm-bake` or results are unpredictable
(see "Caveats" below). The output is:

    From hello-world.baked.wasm - Hello, foo!

## How It Works

To save space, I'll just list what it does as a set of bulleted points:

* TODO: explain

**Caveats**

* TODO: explain exact args needed at bake time
* TODO: explain non-pure code in init, e.g. time
* TODO: explain async code in init
* TODO: explain that it relies on knowledge of internals

**Why was it not written in Go?**

I needed an interpreter that I could step/stop when I wanted, customize, and inspect all sorts of information about the
stack and the instructions. As is common in Go projets, the WASM interpreters I have seen do not expose the internals I
need. Also I have a project I built and am familiar with, [Asmble](https://github.com/cretz/asmble), that does have a
steppable interpreter with internals exposed. So it was just easier for this proof of concept to use that. If any
concepts from this PoC deserve a more stable implementation, a Go implementation would be desired.